## 1st
- 6/4 18:00 ~ 
- n行1列について、1行目を 0 とする
- 2行目以降、0 を 01, 1 を 10 に変換していく
- ex. n = 3 の時、以下のようになれば良い
- ![img.png](img.png)
- このようなn行1列要素のn行要素の左からk番目を返却する問題
- Constraints:
  - `1 <= n <= 30`
  - `1 <= k <= 2^n - 1`
- 上記から、k は最大 10^9 相当になるから BS っぽくやらないとTLEする
- `n = 8` を考えた時にえらいことになるのは目に見えているので。。
- ![img_1.png](img_1.png)
- `n = 8` の時に、3回の計算で返したい
- 再帰で考えることは決まっているので、k を k / 2 としていくようなイメージになるはず。。？
- いや、木をイメージしたほうがわかりいい？
- 18:13 うん、わからん！
```java
public class Solution {
    public int kthGrammar(int n, int k) {
        // ベースケース：最初の行の1文字目は 0
        if (n == 1 && k == 1) {
            return 0;
        }

        // 親のインデックス（k/2、ただし1-indexedなので (k+1)/2）
        int parent = kthGrammar(n - 1, (k + 1) / 2);

        // k が奇数なら親の左の子 → 親と同じ
        // k が偶数なら親の右の子 → 親と反転
        boolean isKEven = k % 2 == 0;
        if (!isKEven) {
            return parent;
        } else {
            return 1 - parent;
        }
    }
}
```
- いったん理解した
- ![img_2.png](img_2.png)
- 親の要素は k + 1 / 2 で求まる
- この手の問題、上から考えるか下から考えるかの2パターンで、したからの場合は親の位置重要がちなので覚えちゃいたい
## 2nd

## 3rd

## 4th

## 5th
