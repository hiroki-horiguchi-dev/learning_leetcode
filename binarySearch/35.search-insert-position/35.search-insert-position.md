## 目的
- ソートされた個別の整数の配列とターゲット値が指定されている場合、ターゲットが見つかった場合はインデックスを返す
- 見つからない場合は、順番に挿入された場合のインデックスを返す

- 実行時の複雑さを伴うアルゴリズムを記述する必要があります O(log n)。

Example 1:

```
Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4
```

## 解法
- すぐ思いつく解法は以下
```kotlin
class Solution {
    fun searchInsert(nums: IntArray, target: Int): Int {
        /// for ループを一周回して target と等しい値があるかどうかを探る
        /// 一致するものがあるかどうかでフラグを立てる
        /// 一致するものがなければもう一度 for ループを回して、target をディクリメントして合致する値の次のインデックスを返却する
        /// 最小計算量は O(N), 最大計算量は 2 * O(N)
    }
}
```
- まあでもこれよりもっといい解法があるってことよね

## 別解
- 二分探索を使いましょう
- ヒントはすでにソートされている、ということ
```kotlin
class Solution {
    fun searchInsert(nums: IntArray, target: Int): Int {
        var low = 0
        var high = nums.size - 1

        while (low <= high) {
            val mid = low + (high - low) / 2

            when {
                nums[mid] == target -> return mid // ターゲットが見つかった場合
                nums[mid] < target -> low = mid + 1 // ターゲットが右側にある場合
                else -> high = mid - 1 // ターゲットが左側にある場合
            }
        }
        return low // 挿入位置を返す
    }
}
```

## 所感
- しかしだ、これをプロダクトコードに書いたときに読み手が直感的に理解できるのは二分探索じゃないと思うんだよな

## 1st
```kotlin
    fun searchInsert(nums: IntArray, target: Int): Int {
        var low = 0
        var high = nums.size - 1

        while (low <= high) {
            val mid = low + (high - low) / 2

            when {
                nums[mid] == target -> return mid // ターゲットが見つかった場合
                nums[mid] < target -> low = mid + 1 // ターゲットが右側にある場合
                else -> high = mid - 1 // ターゲットが左側にある場合
            }
        }
        return low // 挿入位置を返す
    }
```
- mid の計算について、オーバーフローの可能性があるためこの計算方法をとっている
- `low = 1,000,000,000, high = 2,000,000,000` この場合、Kotlin の Int.MaxValue が `2,147,483,647` のため、mid = (low + high) / 2 だとオーバーフローして正確な計算結果が出ないので

## 2nd

## 3rd

## 4th

## 5th
