## 目的
- 昇順にソートされた長さの配列が、 1～n回回転するとします。たとえば、配列は次のようになります。
- nums = [0,1,2,4,5,6,7]


- [4,5,6,7,0,1,2] 4回回転した場合。
- [0,1,2,4,5,6,7] 7回回転した場合。
- [a[0], a[1], a[2], ..., a[n-1]] 配列を1 回回転すると、[a[n-1], a[0], a[1], a[2], ..., a[n-2]]配列 になることに注意してください

- 一意のnums要素のソートされた回転配列が与えられた場合、この配列の最小要素を返します。

- O(log n) timeで実行されるアルゴリズムを記述する必要があります 

## まず思いついた解法
- min = nums[min] を取得 O(N)
- min の位置をリストから取得 O(N)
- 計算量は 2 * O(N)

## leetcode の解法
- なかったので chatgpt 
```kotlin
fun findMin(nums: IntArray): Int {
    var left = 0
    var right = nums.size - 1

    while (left < right) {
        val mid = (left + right) / 2

        // nums[mid] > nums[right] の場合、最小値は右側にある
        if (nums[mid] > nums[right]) {
            left = mid + 1
        } else {
            // nums[mid] <= nums[right] の場合、最小値は左側またはmidにある
            right = mid
        }
    }

    return nums[left] // 最小値
}

```

## 所感
- まあ書き出していけば理解できた

## 1st
```kotlin
class Solution {
    fun findMin(nums: IntArray): Int {
        /// 方針
        /// 最小値を見つける
        /// 二分探索で左右中央から絞っていく
        /// 最終的には left の値を返すことにする
        /// input のnums はサイズが 5000 なので、計算時にオーバーフローは考慮しない

        var left = 0
        var right = nums.size - 1

        while (left < right) {

            val mid = (left + right) / 2

            if (nums[mid] > nums[right]) {
                left = mid + 1
            } else {
                right = mid
            }
        }

        return nums[left]
    }
}
```

## 2nd

## 3rd

## 4th

## 5th
