## 目的
- 重複要素を含むint配列が与えられる
- 自然数kが与えられる
- int 配列の中で重複する要素を数え、多い順にk番目まで重複する要素を出力する

## まず思いついた解法
- HashMap 使ってカウントして、key,value 使ってうまいことリストに格納すればいいんちゃう？
- ヒープを使う発想が出てこなくてわろた

## 事前学習
- 方針として2つあるみたい
- 目的がお勉強なので両方やってみる
  1. HashMap 使ってカウントするバケットソート
  2. ヒープを使う方法

## 1st
### 1. バケットソート
  - イメージは [wiki概要](https://ja.wikipedia.org/wiki/%E3%83%90%E3%82%B1%E3%83%83%E3%83%88%E3%82%BD%E3%83%BC%E3%83%88#%E6%A6%82%E5%BF%B5)を読んでみて
  - 重複要素をカウント、二次元リストを用意しそのリスト内の重複した数に該当するインデックスに重複した数を保存する方法
  - AC するか怪しいけど一旦考えたコード
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // バケットソートパターン
        HashMap<Integer, Integer> map = new HashMap<>();
        ArrayList<ArrayList<Integer>> list = new ArrayList<>();
        ArrayList<Integer> result = new ArrayList<>();

        // 重複カウント処理 O(n)
        for (int num : nums) {
            if (map.containsKey(num)) {
                int value = map.get(num) + 1;
                map.put(num, value);
            } else {
                map.put(num, 1);
            }
        }

        // nums + 1 の空リストを二次元配列へ突っ込んでおく
        for (int i = 0; i <= nums.length; i++) {
            list.add(new ArrayList<Integer>());
        }

        // map から key と value を持ってきて、二次元リストの value 位置に key を保存
        Set<Integer> keys = map.keySet();
        for (int key : keys) {
            int value = map.get(key);
            list.get(value).add(key);
        }

        // 結果を得るために、リストの最後からk個の要素を取得
        for (int i = list.size() - 1; i >= 0 && k > 0; i--) {
            for (int num : list.get(i)) {
                if (k-- > 0) {
                    result.add(num);
                } else {
                    break;
                }
            }
        }

        return result.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

- chatGpt に綺麗に書かせた方のコード
- 最後の stream に渡して int 配列を作るところは本当にこうじゃなきゃダメなのか。。。
- 明日の復習でもっといいコード書けるか試してみよ
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // Step 1: 出現回数をカウントするための HashMap を作成
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        
        // nums 配列の各要素について、その出現回数をカウント
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // Step 2: 出現回数のリスト（バケットソートに相当するもの）を作成
        // 出現回数の最大値は nums.length であるため、リストの長さは nums.length + 1 にする
        ArrayList<ArrayList<Integer>> buckets = new ArrayList<>();
        
        // 空のリストを nums.length + 1 個作成
        for (int i = 0; i <= nums.length; i++) {
            buckets.add(new ArrayList<>());
        }

        // Step 3: 出現回数に応じたバケットに要素を追加
        for (int num : frequencyMap.keySet()) {
            int count = frequencyMap.get(num);  // 出現回数
            buckets.get(count).add(num);        // 出現回数のバケットに追加
        }

        // Step 4: 結果となる最頻出の k 個の要素を取得
        ArrayList<Integer> result = new ArrayList<>();
        
        // バケットリストを後ろからループして、頻度が高い順に要素を追加
        for (int i = buckets.size() - 1; i >= 0 && result.size() < k; i--) {
            for (int num : buckets.get(i)) {
                if (result.size() < k) {
                    result.add(num);
                } else {
                    break;  // k 個取り出したら終了
                }
            }
        }

        // Step 5: 結果を int 配列に変換して返す
        return result.stream().mapToInt(Integer::intValue).toArray();
    }
}

```

### ヒープを使った実装
- 方針も何も思いつかないので chatGpt に雑に投げる



## 2nd

## 3rd

## 4th

## 5th
