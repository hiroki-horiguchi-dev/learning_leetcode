## 目的
- house robber 1 に制約が一つ追加された
- 家は環状に並んでおり、最初の家と最後の家は隣接しているため同時に盗むことはできない

## 解法
- house robber 1 と同様に解く方法があるんだろうなあとあれこれ考えたが、思いつかないので答えみた
- 先頭と最後を分けて考える方法だろうな、と思っている

## 別解
- みる余裕なし

## 所感
- 特になし

## 1st
```kotlin
    fun rob(nums: IntArray): Int {
        if (nums.size == 1) return nums[0]
        if (nums.size == 2) return maxOf(nums[0], nums[1])

        /// 最初の家を含むパターン、含まないパターン
        val robFirstToSecond = robLinear(nums, 0, nums.size - 2)
        val robSecondToLast  = robLinear(nums, 1, nums.size - 1)

        return maxOf(robFirstToSecond, robSecondToLast)
    }

    private fun robLinear(
        nums: IntArray,
        start: Int,
        end: Int
    ): Int {
        var prev1 = 0
        var prev2 = 0
        
        for (i in start..end) {
            val temp = prev1
            prev1 = maxOf(prev1, prev2 + nums[i])
            prev2 = temp
        }

        return prev1
    }
```
- うーん、最初の家含む含まないの部分で配列を分けようという思考がスパッと行かなかった --> 2nd で dp の目的「課題を分割して最適な処理を実装する」がわかってきた気がする
- [House Robber II - Dynamic Programming - Leetcode 213 1:27~
](https://www.youtube.com/watch?v=rWAJCfYYOvM&t=87s) 

## 2nd
```kotlin
    fun rob(nums: IntArray): Int {
        if (nums.isEmpty()) return 0
        if (nums.size == 1) return nums[0]
        if (nums.size == 2) return maxOf(nums[0], nums[1])

        return maxOf(robHelper(nums, 0, nums.size - 2), robHelper(nums, 1, nums.size - 1))
    }

    private fun robHelper(nums: IntArray, start: Int, end: Int): Int {
        val first = nums[start]
        val second = nums[start+1]
        val loopStart = start + 2

        var prev1 = maxOf(first, second)
        var prev2 = first

        for (i in loopStart..end) {
             val temp = prev1
             prev1 = maxOf(prev1, nums[i] + prev2)
             prev2 = temp
        }

        return prev1
    }
```
- 198 rob house の復習を受けて、探索部分を一部変更した
- chatGpt に通して問題ないと評価もらったのでおk
 ![alt text](image.png)

## 3rd

## 4th

## 5th
