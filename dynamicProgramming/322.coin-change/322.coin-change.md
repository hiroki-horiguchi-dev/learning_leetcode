## 目的
- 整数の配列 coins が与えられる。この配列は異なる硬貨の種類を表す
- 整数 amount が与えられる。これは合計金額を表す
- この amount を作るために必要な最小の硬貨の枚数を返す
- もし、その金額を硬貨の組み合わせで作ることができない場合は、-1 を返す
- 各種類の硬貨は無限に持っていると仮定する

## 解法
- int count みたいな counter を用意してこれを返却する
- coins がソートされていなければソートする
- coins で与えられた最大値で amount を割り、商を coutner へ保存
- 商が0の場合は次へ
- coins で与えられた最大値の次に大きい値で amount を割り、商を coutner へ保存、余りを temp で管理
- ループが終われば counter を返却する
- これを5から最小値まで繰り返せば良さそうか？
- うまい方法があるはず。。。

## 別解

## 所感

## 1st
```kotlin
    fun coinChange(coins: IntArray, amount: Int): Int {
        /// coins = [1,2,5], amount = 11

        val dp = IntArray(amount + 1) { amount + 1 } 
        /// dp = [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]

        dp[0] = 0
        /// dp = [0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]

        /// amount = 11, coins = [1,2,5]
        for (i in 1..amount) {
            /// i = 1,2,3,4,5,6,7,8,9,0,10,11
            for(coin in coins) {
                if (i - coin >= 0) {
                    /// i = 1
                    ///     1 - (1,2,5)
                    /// i = 2
                    ///     2 - (1,2,5)
                    /// i = 3
                    ///     3 - (1,2,5)
                    /// i = 4
                    ///     4 - (1,2,5)
                    dp[i] = minOf(dp[i], dp[i-coin] + 1)
                }
            }
        }

        return if (dp[amount] > amount) - 1 else dp[amount]
    }
```
- 初見だと意味わからん
- Bottom Up というアルゴリズムの一部らしい

## 2nd

## 3rd

## 4th

## 5th
