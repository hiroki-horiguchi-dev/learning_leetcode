# 背景
- 問題を解いていく上で、この問題の解法って必ずしも dp を使わなくてもいいよね？と思う問題が多々ある
- たとえば、最短経路問題
- これは矢印の数を数え、その順列を考える高校数学の知識を使えば dp なんぞ使わなくても解けてしまう
- しかしそう考えてしまうと、この章で dp を学習する意味、意図を掴めないままに学習を進めることになる
- そうなると、今後に生きるであろう dp の知識をみすみす捨てることになり非常に勿体無い
- したがって、このタイミングで dp を学習する意図と目的、メリットをこの資料にまとめておくことにする

# DP を学ぶ目的

## まず、DP とは？
- 「問題を小さな部分問題に分解し、その部分問題の結果を再利用して全体の問題を解く」という考え方

## メリット
1. 問題を効率的に解く力がつく：特に大規模な問題や最適化問題で役立つ
2. 時間・空間効率の改善：再計算を避け、計算量を大幅に減少させることができる。
3. 複雑な問題を段階的に解決するスキルが身につく：大きな問題を小さな部分問題に分けて解決する発想が、より複雑な課題に適用できる。

## 具体例
フィボナッチ数列を例にして、動的計画法を使ったコードの違いを見てみましょう。

###  一般的な再帰を用いた方法
```kotlin
fun fib(n: Int): Int {
    if (n <= 1) return n
    return fib(n - 1) + fib(n - 2)
}
```
- このコードはシンプルですが、同じ計算を何度も繰り返すため、時間がかかる
- fib(5)を求めるとき、fib(4) と fib(3) を再計算してしまう

### 動的計画法で解く場合
```kotlin
fun fib(n: Int): Int {
    if (n <= 1) return n
    val dp = IntArray(n + 1)
    dp[0] = 0
    dp[1] = 1
    for (i in 2..n) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }
    return dp[n]
}
```
- この方法では、部分的な結果をdpという配列に保存して、再計算を防ぐ
- このため、時間効率がO(n)に改善される